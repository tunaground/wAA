<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wAA - ASCII Art Editor</title>
    <style>
        @font-face {
            font-family: "Saitamaar";
            src: url("https://da1eth.github.io/AA/HeadKasen.woff2") format("woff2");
            font-display: swap;
        }

        @font-face {
            font-family: "Saitamaar";
            font-style: normal;
            font-weight: 400;
            src: url("https://cdn.jsdelivr.net/font-nanum/1.0/nanumgothiccoding/v2/NanumGothicCoding-Regular.eot");
            src: url("https://cdn.jsdelivr.net/font-nanum/1.0/nanumgothiccoding/v2/NanumGothicCoding-Regular.eot?#iefix") format('embedded-opentype'), url("https://cdn.jsdelivr.net/font-nanum/1.0/nanumgothiccoding/v2/NanumGothicCoding-Regular.woff") format('woff'), url("https://cdn.jsdelivr.net/font-nanum/1.0/nanumgothiccoding/v2/NanumGothicCoding-Regular.ttf") format('truetype');
            unicode-range: U+AC00-D7A3, U+3130-318F;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #eeeeee;
            --accent: #2196f3;
            --accent-hover: #1976d2;
            --text-primary: #212121;
            --text-secondary: #757575;
            --border: #e0e0e0;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #2a2a2a;
            --accent: #2196f3;
            --accent-hover: #42a5f5;
            --text-primary: #e0e0e0;
            --text-secondary: #888888;
            --border: #333333;
            --shadow: rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent);
        }

        header p {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        /* Main Container */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .panel {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1rem;
        }

        .panel-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 0.75rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: block;
            font-size: 0.8125rem;
            margin-bottom: 0.375rem;
            color: var(--text-primary);
        }

        /* Input styling */
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="file"] {
            display: none;
        }

        .file-input-wrapper {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8125rem;
            font-weight: 500;
            transition: all 0.15s ease;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--border);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: #3a3a5a;
        }

        .btn-small {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
        }

        /* Toolbar */
        .toolbar {
            background: var(--bg-secondary);
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .toolbar-group {
            display: flex;
            gap: 0.25rem;
            padding-right: 0.75rem;
            border-right: 1px solid var(--border);
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.15s ease;
        }

        .toolbar-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
        }

        .toolbar-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .canvas-wrapper {
            flex: 1;
            padding: 1rem;
            overflow: auto;
            background:
                linear-gradient(90deg, var(--border) 1px, transparent 1px),
                linear-gradient(var(--border) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .canvas {
            display: flex;
            width: 800px;
            height: 600px;
            background: var(--bg-primary);
            border: 2px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px var(--shadow);
            resize: both;
            min-width: 200px;
            min-height: 100px;
        }

        .bezel {
            flex: 1;
            position: relative;
            margin: 2px;
        }

        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            font-family: 'Saitamaar', monospace;
            font-size: 16px;
            margin: 0;
            padding: 2px;
            border: 0;
            line-height: 1.125em;
        }

        #panel {
            z-index: 3;
            user-select: none;
            overflow: hidden;
            background-color: transparent;
            color: var(--text-primary);
            white-space: pre;
        }

        #writer {
            overflow-x: scroll;
            z-index: 2;
            resize: none;
            background-color: transparent;
            color: transparent;
            caret-color: var(--accent);
            outline: none;
        }

        #backgroundScreen {
            z-index: 1;
            background-size: auto;
            background-repeat: no-repeat;
            background-position: center;
        }

        /* Character styling */
        .char {
            transition: background-color 0.1s ease;
        }

        .show-grid .char:nth-child(odd) {
            background-color: rgba(255, 0, 0, 0.25);
        }

        .show-grid .char:nth-child(even) {
            background-color: rgba(0, 100, 255, 0.25);
        }

        .char::selection {
            background-color: transparent;
            color: inherit;
        }

        .eof {
            color: var(--text-secondary);
            opacity: 0.3;
        }

        .selection-box {
            position: absolute;
            border: 2px solid var(--accent);
            background-color: rgba(233, 69, 96, 0.15);
            pointer-events: none;
            z-index: 100;
            border-radius: 2px;
        }

        .highlight {
            background-color: rgba(255, 230, 0, 0.7) !important;
            border-radius: 2px;
        }

        /* Dots Panel */
        .dots-panel {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.25rem;
        }

        .dot-btn {
            padding: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.6875rem;
            transition: all 0.15s ease;
        }

        .dot-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
        }

        /* Help section */
        .help-section {
            margin-top: auto;
        }

        .help-toggle {
            width: 100%;
            text-align: left;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.8125rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .help-toggle:hover {
            color: var(--text-primary);
        }

        .help-content {
            display: none;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-top: 0.5rem;
        }

        .help-content.active {
            display: block;
        }

        .help-content ul {
            list-style: none;
            font-size: 0.75rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .help-content li {
            margin-bottom: 0.5rem;
            padding-left: 1rem;
            position: relative;
        }

        .help-content li::before {
            content: "•";
            position: absolute;
            left: 0;
            color: var(--accent);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Status bar */
        .status-bar {
            background: var(--bg-secondary);
            padding: 0.5rem 1rem;
            border-top: 1px solid var(--border);
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        /* Theme toggle */
        .theme-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .theme-toggle:hover {
            background: var(--accent);
            border-color: var(--accent);
        }

        .icon-moon { display: none; }
        .icon-sun { display: block; }

        [data-theme="dark"] .icon-moon { display: block; }
        [data-theme="dark"] .icon-sun { display: none; }

        /* Selection indicator */
        .selection-indicator {
            background: var(--accent);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>wAA</h1>
            <p>웹 아스키 아트 에디터</p>
        </div>
        <button class="theme-toggle" onclick="toggleTheme()" title="다크 모드 전환">
            <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
            <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
        </button>
    </header>

    <div class="main-container">
        <aside class="sidebar">
            <!-- Background Controls -->
            <div class="panel">
                <div class="panel-title">배경 이미지</div>
                <div class="control-group">
                    <div class="file-input-wrapper">
                        <label class="btn btn-primary btn-small" for="backgroundInput">
                            파일 선택
                        </label>
                        <button class="btn btn-secondary btn-small" onclick="clearBackground()">삭제</button>
                    </div>
                    <input type="file" id="backgroundInput" accept="image/*"/>
                </div>
                <div class="control-group">
                    <label class="control-label">불투명도</label>
                    <input type="range" id="opacitySlider" min="0" max="100" value="100">
                </div>
                <div class="control-group">
                    <label class="control-label">흑백</label>
                    <input type="range" id="grayscaleSlider" min="0" max="100" value="0">
                </div>
                <div class="control-group">
                    <label class="control-label">크기 <span id="backgroundSizeValue">100%</span></label>
                    <input type="range" id="backgroundSizeSlider" min="10" max="500" value="100">
                </div>
                <div class="control-group">
                    <label class="control-label">X 위치</label>
                    <input type="range" id="backgroundXSlider" min="0" max="100" value="50">
                </div>
                <div class="control-group">
                    <label class="control-label">Y 위치</label>
                    <input type="range" id="backgroundYSlider" min="0" max="100" value="50">
                </div>
            </div>

            <!-- Font Controls -->
            <div class="panel">
                <div class="panel-title">폰트 설정</div>
                <div class="control-group">
                    <label class="control-label">폰트 크기</label>
                    <input type="range" id="fontSizeSlider" min="8" max="64" value="16">
                </div>
            </div>

            <!-- Canvas Settings -->
            <div class="panel">
                <div class="panel-title">캔버스 설정</div>
                <div class="control-group">
                    <label class="control-label" style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="fixedCanvasCheckbox"> 캔버스 크기 고정
                    </label>
                </div>
            </div>

            <!-- Dot Characters -->
            <div class="panel">
                <div class="panel-title">도트 문자</div>
                <div class="dots-panel">
                    <button class="dot-btn" onclick="addDot(dots[0])">도트 1</button>
                    <button class="dot-btn" onclick="addDot(dots[1])">도트 2</button>
                    <button class="dot-btn" onclick="addDot(dots[2])">도트 3</button>
                    <button class="dot-btn" onclick="addDot(dots[3])">도트 4</button>
                    <button class="dot-btn" onclick="addDot(dots[4])">도트 5</button>
                    <button class="dot-btn" onclick="addDot(dots[5])">도트 6</button>
                    <button class="dot-btn" onclick="addDot(dots[6])">도트 7</button>
                    <button class="dot-btn" onclick="addDot(dots[7])">도트 8</button>
                    <button class="dot-btn" onclick="addDot(dots[8])">도트 9</button>
                </div>
            </div>

            <!-- Save/Load -->
            <div class="panel">
                <div class="panel-title">저장 / 불러오기</div>
                <div class="control-group">
                    <div id="currentFileDisplay" style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.5rem; word-break: break-all;">새 프로젝트</div>
                    <div class="file-input-wrapper">
                        <button class="btn btn-primary btn-small" onclick="saveProject()">저장</button>
                        <button class="btn btn-secondary btn-small" onclick="saveProjectAs()">다른 이름</button>
                    </div>
                    <div class="file-input-wrapper" style="margin-top: 0.5rem;">
                        <button class="btn btn-secondary btn-small" onclick="openProject()">불러오기</button>
                        <button class="btn btn-secondary btn-small" onclick="newProject()">새 프로젝트</button>
                    </div>
                    <input type="file" id="loadInput" accept=".waa,.json" style="display:none;"/>
                </div>
            </div>

            <!-- Help -->
            <div class="help-section">
                <button class="help-toggle" onclick="toggleHelp()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                    도움말 & 단축키
                </button>
                <div class="help-content" id="helpContent">
                    <ul>
                        <li>캔버스 모서리 드래그로 크기 조절</li>
                        <li>클릭 후 드래그로 문자 선택</li>
                        <li>Shift + 방향키로 선택 영역 이동</li>
                        <li>Ctrl/Cmd + C/X/V로 복사/잘라내기/붙여넣기</li>
                        <li>Escape 또는 빈 영역 클릭으로 선택 해제</li>
                        <li>스페이스바로 도트 너비 순환</li>
                        <li>Ctrl/Cmd + N으로 새 프로젝트</li>
                        <li>Ctrl/Cmd + O로 불러오기</li>
                        <li>Ctrl/Cmd + S로 저장</li>
                        <li>Ctrl/Cmd + Shift + S로 다른 이름 저장</li>
                    </ul>
                </div>
            </div>
        </aside>

        <main class="canvas-container">
            <!-- Toolbar -->
            <div class="toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn" onclick="moveSelected(-1, 0)" title="왼쪽 이동">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>
                    </button>
                    <button class="toolbar-btn" onclick="moveSelected(1, 0)" title="오른쪽 이동">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
                    </button>
                    <button class="toolbar-btn" onclick="moveSelected(0, -1)" title="위로 이동">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"/></svg>
                    </button>
                    <button class="toolbar-btn" onclick="moveSelected(0, 1)" title="아래로 이동">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>
                    </button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="gridToggle" onclick="toggleGrid()" title="문자 그리드 전환">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>
                    </button>
                </div>
                <div class="toolbar-group" id="selectionGroup" style="display: none;">
                    <span class="selection-indicator">선택 모드</span>
                    <button class="toolbar-btn" onclick="clearSelection()" title="선택 해제 (Esc)">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                    </button>
                </div>
            </div>

            <!-- Canvas -->
            <div class="canvas-wrapper">
                <div class="canvas">
                    <div class="bezel">
                        <div id="panel" class="screen" onclick="focusWriter()"></div>
                        <textarea id="writer" class="screen" spellcheck="false"></textarea>
                        <div id="backgroundScreen" class="screen"></div>
                    </div>
                </div>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <span id="statusText">Ready</span>
                <span id="cursorPosition">Ln 0, Col 0</span>
            </div>
        </main>
    </div>

<script>
    let history = [];
    let lastValidValue = '';
    let isRestoring = false;

    const panel = document.querySelector('#panel');
    const writer = document.querySelector('#writer');
    const backgroundScreen = document.querySelector('#backgroundScreen');
    const statusText = document.querySelector('#statusText');
    const cursorPosition = document.querySelector('#cursorPosition');

    const backgroundInput = document.querySelector('#backgroundInput');

    const fontSizeSlider = document.querySelector('#fontSizeSlider');
    const opacitySlider = document.querySelector('#opacitySlider');
    const grayscaleSlider = document.querySelector('#grayscaleSlider');
    const backgroundSizeSlider = document.querySelector('#backgroundSizeSlider');
    const backgroundXSlider = document.querySelector('#backgroundXSlider');
    const backgroundYSlider = document.querySelector('#backgroundYSlider');

    let originalImageWidth = 0;
    let originalImageHeight = 0;

    function toggleHelp() {
        const helpContent = document.getElementById('helpContent');
        helpContent.classList.toggle('active');
    }

    function toggleGrid() {
        panel.classList.toggle('show-grid');
        const isOn = panel.classList.contains('show-grid');
        document.getElementById('gridToggle').style.background = isOn ? 'var(--accent)' : '';
        updateStatus(isOn ? '문자 그리드 켜짐' : '문자 그리드 꺼짐');
    }

    function clearSelection() {
        document.querySelectorAll('.highlight').forEach(el => {
            el.classList.remove('highlight');
        });
        updateSelectionUI();
        updateStatus('선택 해제됨');
        writer.focus();
    }

    function updateSelectionUI() {
        const hasSelection = document.querySelector('.highlight') !== null;
        document.getElementById('selectionGroup').style.display = hasSelection ? 'flex' : 'none';
    }

    // Escape key to clear selection
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            const hasSelection = document.querySelector('.highlight') !== null;
            if (hasSelection) {
                clearSelection();
            }
        }
    });

    function updateStatus(text) {
        statusText.textContent = text;
    }

    function updateCursorPosition() {
        const pos = writer.selectionStart;
        const text = writer.value.substring(0, pos);
        const lines = text.split('\n');
        const line = lines.length;
        const col = lines[lines.length - 1].length;
        cursorPosition.textContent = `Ln ${line}, Col ${col}`;
    }

    writer.addEventListener('click', updateCursorPosition);
    writer.addEventListener('keyup', updateCursorPosition);

    // Dot characters array (narrowest to widest)
    const dots = [
        '\u200A',           // 1: Hair Space
        '\u2009',           // 2: Thin Space
        '\u2006',           // 3: Six-Per-Em Space
        '\u2005',           // 4: Four-Per-Em Space
        ' ',                // 5: Space (U+0020)
        ' \u200A',          // 6: Space + Hair
        ' \u2009',          // 7: Space + Thin
        ' \u2006',          // 8: Space + Six-Per-Em
        ' \u2005',          // 9: Space + Four-Per-Em
    ];

    // Space sequence state
    let spaceIndex = 0;
    let spaceStartPos = -1;
    let currentDotLength = 0;

    function resetSpaceSequence() {
        spaceIndex = 0;
        spaceStartPos = -1;
        currentDotLength = 0;
    }

    function getDotString(index) {
        const cycleCount = Math.floor(index / 9);
        const dotIndex = index % 9;
        let result = '';
        for (let i = 0; i < cycleCount; i++) {
            result += dots[8]; // dot 9 (가장 넓음)
        }
        result += dots[dotIndex];
        return result;
    }

    function addDot(str) {
        writer.focus();
        resetSpaceSequence();

        const startPos = writer.selectionStart;
        const endPos = writer.selectionEnd;

        const textBefore = writer.value.substring(0, startPos);
        const textAfter = writer.value.substring(endPos, writer.value.length);

        writer.value = textBefore + str + textAfter;
        writer.selectionStart = writer.selectionEnd = startPos + str.length;

        writer.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));
        updateStatus('도트 문자 삽입됨');
    }

    // Spacebar handler
    writer.addEventListener('keydown', function(e) {
        if (e.key === ' ') {
            e.preventDefault();

            const currentPos = writer.selectionStart;

            // Check if continuing from previous dot sequence
            if (spaceStartPos === -1) {
                spaceStartPos = currentPos;
            } else if (currentPos !== spaceStartPos + currentDotLength) {
                resetSpaceSequence();
                spaceStartPos = currentPos;
            }

            // Remove previous dot string
            const textBefore = writer.value.substring(0, spaceStartPos);
            const textAfter = writer.value.substring(spaceStartPos + currentDotLength);

            // Get new dot string
            const newDotStr = getDotString(spaceIndex);
            currentDotLength = newDotStr.length;

            writer.value = textBefore + newDotStr + textAfter;
            writer.selectionStart = writer.selectionEnd = spaceStartPos + currentDotLength;

            spaceIndex++;

            writer.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));
            updateStatus(`Dot ${(spaceIndex - 1) % 9 + 1} (cycle ${Math.floor((spaceIndex - 1) / 9) + 1})`);
        } else if (!e.ctrlKey && !e.metaKey && !e.altKey) {
            resetSpaceSequence();
        }
    });

    function decodeHtmlEntity(encodedStr) {
        const textArea = document.createElement('textarea');
        textArea.innerHTML = encodedStr;
        return textArea.value;
    }

    function clearBackground() {
        backgroundInput.value = '';
        backgroundScreen.style.backgroundImage = '';
        originalImageWidth = 0;
        originalImageHeight = 0;
        updateStatus('배경 이미지 삭제됨');
    }

    // Save/Load functions
    let currentFileHandle = null;
    let currentFileName = null;

    function updateFileDisplay() {
        const display = document.getElementById('currentFileDisplay');
        display.textContent = currentFileName || '새 프로젝트';
    }

    function getProjectData() {
        return {
            version: 1,
            content: writer.value,
            font: {
                size: fontSizeSlider.value
            },
            background: {
                image: backgroundScreen.style.backgroundImage,
                originalWidth: originalImageWidth,
                originalHeight: originalImageHeight,
                opacity: opacitySlider.value,
                grayscale: grayscaleSlider.value,
                size: backgroundSizeSlider.value,
                positionX: backgroundXSlider.value,
                positionY: backgroundYSlider.value
            },
            theme: document.body.getAttribute('data-theme') || 'light'
        };
    }

    async function saveProject() {
        const projectData = getProjectData();
        const jsonString = JSON.stringify(projectData, null, 2);

        // File System Access API 지원 시
        if ('showSaveFilePicker' in window) {
            try {
                // 기존 파일 핸들이 있으면 덮어쓰기
                if (currentFileHandle) {
                    const writable = await currentFileHandle.createWritable();
                    await writable.write(jsonString);
                    await writable.close();
                    updateStatus(`저장됨: ${currentFileName}`);
                    updateFileDisplay();
                    return;
                }

                // 새 파일 저장
                const handle = await window.showSaveFilePicker({
                    suggestedName: 'project.waa',
                    types: [{
                        description: 'wAA Project',
                        accept: { 'application/json': ['.waa'] }
                    }]
                });
                currentFileHandle = handle;
                currentFileName = handle.name;

                const writable = await handle.createWritable();
                await writable.write(jsonString);
                await writable.close();
                updateStatus(`저장됨: ${currentFileName}`);
                updateFileDisplay();
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error(err);
                    updateStatus('저장 실패');
                }
            }
        } else {
            // 폴백: 기존 다운로드 방식
            const filename = prompt('파일 이름을 입력하세요:', currentFileName || 'project');
            if (filename === null) return;

            currentFileName = filename + '.waa';
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentFileName;
            a.click();
            URL.revokeObjectURL(url);
            updateStatus('프로젝트 저장됨');
            updateFileDisplay();
        }
    }

    async function saveProjectAs() {
        currentFileHandle = null;
        currentFileName = null;
        updateFileDisplay();
        await saveProject();
    }

    function newProject() {
        if (!confirm('현재 작업을 저장하지 않으면 잃어버립니다. 계속하시겠습니까?')) {
            return;
        }

        // 파일 핸들 초기화
        currentFileHandle = null;
        currentFileName = null;
        updateFileDisplay();

        // 캔버스 초기화
        writer.value = '';
        lastValidValue = '';
        writer.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));

        // 폰트 초기화
        fontSizeSlider.value = 16;
        panel.style.fontSize = '16px';
        writer.style.fontSize = '16px';

        // 배경 초기화
        clearBackground();
        opacitySlider.value = 100;
        backgroundScreen.style.opacity = 1;
        grayscaleSlider.value = 0;
        backgroundScreen.style.filter = 'grayscale(0%)';
        backgroundSizeSlider.value = 100;
        document.getElementById('backgroundSizeValue').textContent = '100%';
        backgroundXSlider.value = 50;
        backgroundScreen.style.backgroundPositionX = '50%';
        backgroundYSlider.value = 50;
        backgroundScreen.style.backgroundPositionY = '50%';

        updateStatus('새 프로젝트');
    }

    function applyProjectData(data, filename) {
        try {
            // Restore content
            writer.value = data.content || '';
            lastValidValue = writer.value;
            writer.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));

            // Restore font
            if (data.font) {
                fontSizeSlider.value = data.font.size;
                const fontSize = data.font.size + 'px';
                panel.style.fontSize = fontSize;
                writer.style.fontSize = fontSize;
            }

            // Restore background
            if (data.background) {
                originalImageWidth = data.background.originalWidth || 0;
                originalImageHeight = data.background.originalHeight || 0;

                if (data.background.image) {
                    backgroundScreen.style.backgroundImage = data.background.image;
                    if (originalImageWidth > 0) {
                        const scale = data.background.size / 100;
                        backgroundScreen.style.backgroundSize = `${originalImageWidth * scale}px ${originalImageHeight * scale}px`;
                    }
                }

                opacitySlider.value = data.background.opacity;
                backgroundScreen.style.opacity = data.background.opacity / 100;

                grayscaleSlider.value = data.background.grayscale;
                backgroundScreen.style.filter = `grayscale(${data.background.grayscale}%)`;

                backgroundSizeSlider.value = data.background.size;
                document.getElementById('backgroundSizeValue').textContent = data.background.size + '%';

                backgroundXSlider.value = data.background.positionX;
                backgroundScreen.style.backgroundPositionX = `${data.background.positionX}%`;

                backgroundYSlider.value = data.background.positionY;
                backgroundScreen.style.backgroundPositionY = `${data.background.positionY}%`;
            }

            // Restore theme
            if (data.theme) {
                document.body.setAttribute('data-theme', data.theme);
                localStorage.setItem('theme', data.theme);
            }

            currentFileName = filename;
            updateFileDisplay();
            updateStatus(`불러옴: ${filename}`);
        } catch (err) {
            updateStatus('파일을 불러올 수 없습니다');
            console.error(err);
        }
    }

    async function openProject() {
        // File System Access API 지원 시
        if ('showOpenFilePicker' in window) {
            try {
                const [handle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'wAA Project',
                        accept: { 'application/json': ['.waa', '.json'] }
                    }]
                });
                currentFileHandle = handle;
                const file = await handle.getFile();
                const text = await file.text();
                const data = JSON.parse(text);
                applyProjectData(data, handle.name);
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error(err);
                    updateStatus('파일을 불러올 수 없습니다');
                }
            }
        } else {
            // 폴백: input 사용
            document.getElementById('loadInput').click();
        }
    }

    document.getElementById('loadInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(evt) {
                try {
                    const data = JSON.parse(evt.target.result);
                    currentFileHandle = null; // 폴백에서는 핸들 없음
                    applyProjectData(data, file.name);
                } catch (err) {
                    updateStatus('파일을 불러올 수 없습니다');
                    console.error(err);
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        }
    });

    fontSizeSlider.addEventListener('input', function () {
        const fontSize = fontSizeSlider.value + 'px';
        panel.style.fontSize = fontSize;
        writer.style.fontSize = fontSize;
    });

    document.getElementById('fixedCanvasCheckbox').addEventListener('change', function () {
        const canvas = document.querySelector('.canvas');
        canvas.style.resize = this.checked ? 'none' : 'both';
    });

    opacitySlider.addEventListener('input', function () {
        backgroundScreen.style.opacity = opacitySlider.value / 100;
    });

    grayscaleSlider.addEventListener('input', function () {
        backgroundScreen.style.filter = `grayscale(${grayscaleSlider.value}%)`;
    });

    backgroundSizeSlider.addEventListener('input', function () {
        document.getElementById('backgroundSizeValue').textContent = backgroundSizeSlider.value + '%';
        if (originalImageWidth > 0) {
            const scale = backgroundSizeSlider.value / 100;
            backgroundScreen.style.backgroundSize = `${originalImageWidth * scale}px ${originalImageHeight * scale}px`;
        }
    })

    backgroundXSlider.addEventListener('input', function () {
        backgroundScreen.style.backgroundPositionX = `${backgroundXSlider.value}%`;
    })

    backgroundYSlider.addEventListener('input', function () {
        backgroundScreen.style.backgroundPositionY = `${backgroundYSlider.value}%`;
    })

    backgroundInput.addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.onload = function() {
                    originalImageWidth = img.naturalWidth;
                    originalImageHeight = img.naturalHeight;
                    backgroundScreen.style.backgroundImage = `url(${e.target.result})`;
                    backgroundScreen.style.backgroundSize = `${originalImageWidth}px ${originalImageHeight}px`;
                    backgroundSizeSlider.value = 100;
                    document.getElementById('backgroundSizeValue').textContent = '100%';
                    updateStatus('배경 이미지 로드됨');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    document.addEventListener('keydown', function (event) {
        if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
            const highlight = document.querySelector('.highlight');
            if (highlight !== null) {
                event.preventDefault();

                const chars = document.querySelectorAll('.char:not(.eof)');
                chars.forEach(c => {
                    c.classList.add('highlight');
                })
                updateStatus('전체 선택됨');
            }
        }

        // Ctrl+S: 저장, Ctrl+Shift+S: 다른 이름으로 저장
        if ((event.ctrlKey || event.metaKey) && event.key === 's') {
            event.preventDefault();
            if (event.shiftKey) {
                saveProjectAs();
            } else {
                saveProject();
            }
        }

        // Ctrl+O: 불러오기
        if ((event.ctrlKey || event.metaKey) && event.key === 'o') {
            event.preventDefault();
            openProject();
        }

        // Ctrl+N: 새 프로젝트
        if ((event.ctrlKey || event.metaKey) && event.key === 'n') {
            event.preventDefault();
            newProject();
        }
    });

    function getSelection() {
        const firstHighlight = document.querySelector('.highlight');
        const selection = [];

        if (firstHighlight !== null) {
            const highlightArray = Array.from(document.querySelectorAll('.highlight'));
            const firstLine = parseInt(highlightArray[0].dataset.line);
            const lastLine = parseInt(highlightArray[highlightArray.length - 1].dataset.line);

            for (let i = (firstLine - firstLine); i <= (lastLine - firstLine); i++) {
                const line = i + firstLine;
                const lineColumns = document.querySelectorAll(`.highlight[data-line="${line}"]`);
                const firstColumnPosition = lineColumns[0].dataset.position;
                const lastColumnPosition = lineColumns[lineColumns.length - 1].dataset.position;
                let value = "";
                lineColumns.forEach((c) => {
                    value += c.innerHTML;
                });
                selection.push({
                    start: firstColumnPosition,
                    end: lastColumnPosition,
                    value: value
                });
            }
        }
        return selection;
    }

    document.addEventListener("copy", function (event) {
        const highlight = document.querySelector('.highlight');

        if (highlight !== null) {
            event.preventDefault();

            const highlightArray = Array.from(document.querySelectorAll('.highlight'));
            const firstLine = highlightArray[0].dataset.line;
            const lastLine = highlightArray[highlightArray.length - 1].dataset.line;
            const v = []

            for (let i = (firstLine - firstLine); i <= (lastLine - firstLine); i++) {
                v.push([""])
            }

            highlightArray.forEach((el) => {
                const l = parseInt(el.dataset.line) - parseInt(firstLine)
                v[l] += el.innerHTML;
            });

            event.clipboardData.setData("application/json", JSON.stringify(v));
            updateStatus('선택 영역 복사됨');
        }
    });

    document.addEventListener('cut', function (event) {
        const highlight = document.querySelector('.highlight');
        if (highlight !== null) {
            event.preventDefault();

            const highlightElements = document.querySelectorAll('.highlight');
            const highlightArray = Array.from(highlightElements);
            const firstLine = highlightArray[0].dataset.line;
            const lastLine = highlightArray[highlightArray.length - 1].dataset.line;
            const v = []

            for (let i = (firstLine - firstLine); i <= (lastLine - firstLine); i++) {
                v.push([""])
            }

            highlightArray.forEach((el, i) => {
                const position = parseInt(el.dataset.position);
                const l = parseInt(el.dataset.line) - parseInt(firstLine)
                v[l] += el.innerHTML;
                writer.value = writer.value.slice(0, position - i) + writer.value.slice(position + 1 - i);
            });

            writer.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));

            event.clipboardData.setData("application/json", JSON.stringify(v));
            updateStatus('선택 영역 잘라내기됨');
        }
    });

    document.addEventListener("paste", function (event) {
        const highlight = document.querySelector('.highlight');
        if (highlight !== null) {
            event.preventDefault();

            const clipboardData = JSON.parse(event.clipboardData.getData('application/json'));
            const firstLine = parseInt(highlight.dataset.line);
            const column = parseInt(highlight.dataset.column);

            clipboardData.forEach((v, i) => {
                const line = firstLine + i;
                const el = document.querySelector('[data-line="' + line + '"][data-column="' + column + '"]');
                const position = parseInt(el.dataset.position);

                const textBefore = writer.value.substring(0, position);
                const textAfter = writer.value.substring(position);

                writer.value = textBefore + decodeHtmlEntity(v) + textAfter

                writer.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));
            });
            updateStatus('붙여넣기됨');
        }
    });

    function moveSelected(x, y) {
        const highlight = document.querySelector('.highlight');
        if (highlight !== null) {
            const contentBackup = writer.value;
            const selectionBackup = []
            document.querySelectorAll('.highlight').forEach((el) => {
                selectionBackup.push(el.dataset.position)
            })
            try {
                const highlightElements = document.querySelectorAll('.highlight');
                const highlightArray = Array.from(highlightElements);
                const firstLine = parseInt(highlightArray[0].dataset.line);
                const firstColumn = parseInt(highlightArray[0].dataset.column);
                const lastLine = parseInt(highlightArray[highlightArray.length - 1].dataset.line);

                const movedLine = firstLine + y;
                const movedColumn = firstColumn + x;

                // 수평 이동 (같은 줄)인 경우 position 기반 계산
                if (y === 0 && firstLine === lastLine) {
                    const firstPosition = parseInt(highlightArray[0].dataset.position);
                    const selectedText = highlightArray.map(el => el.innerHTML).join('');
                    const selectionLength = highlightArray.length;

                    // 이동 가능 체크
                    if (x < 0 && firstColumn + x < 0) throw new Error("Cannot move left");

                    // 오른쪽 이동 시 줄 끝 체크
                    if (x > 0) {
                        const lineEnd = document.querySelector('[data-line="' + firstLine + '"].eof, [data-line="' + (firstLine + 1) + '"][data-column="0"]');
                        const lastSelectedColumn = parseInt(highlightArray[highlightArray.length - 1].dataset.column);
                        const lineLength = lineEnd ? parseInt(lineEnd.dataset.column) : writer.value.split('\n')[firstLine].length;
                        if (lastSelectedColumn + x >= lineLength) throw new Error("Cannot move right");
                    }

                    // 선택 영역 삭제
                    writer.value = writer.value.slice(0, firstPosition) + writer.value.slice(firstPosition + selectionLength);
                    writer.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));

                    // 새 위치에 삽입
                    const targetPosition = firstPosition + x;
                    writer.value = writer.value.slice(0, targetPosition) + decodeHtmlEntity(selectedText) + writer.value.slice(targetPosition);
                    writer.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));

                    // 하이라이트 복원
                    const chars = document.querySelectorAll('.char:not(.eof)');
                    chars.forEach(c => {
                        const pos = parseInt(c.dataset.position);
                        if (pos >= targetPosition && pos < targetPosition + selectionLength) {
                            c.classList.add('highlight');
                        }
                    });
                    updateSelectionUI();
                    updateStatus('선택 영역 이동됨');
                    return;
                }

                const v = []

                for (let i = (firstLine - firstLine); i <= (lastLine - firstLine); i++) {
                    v.push([""])
                }

                highlightArray.forEach((el, i) => {
                    const position = parseInt(el.dataset.position);
                    const l = parseInt(el.dataset.line) - parseInt(firstLine)
                    v[l] += el.innerHTML;
                    writer.value = writer.value.slice(0, position - i) + writer.value.slice(position + 1 - i);
                });

                writer.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));

                const pastedPosition = [];

                v.forEach((v, i) => {
                    const line = movedLine + i;
                    const el = document.querySelector('[data-line="' + line + '"][data-column="' + movedColumn + '"]:not(.eof)');
                    const position = parseInt(el.dataset.position);
                    pastedPosition.push({
                        position,
                        length: v.length
                    });

                    const textBefore = writer.value.substring(0, position);
                    const textAfter = writer.value.substring(position);

                    writer.value = textBefore + decodeHtmlEntity(v) + textAfter

                    writer.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));
                });

                pastedPosition.forEach((v) => {
                    const lastColumn = parseInt(v.position) + parseInt(v.length);
                    const chars = document.querySelectorAll('.char:not(.eof)');

                    chars.forEach(c => {
                        if (parseInt(c.dataset.position) >= parseInt(v.position) && c.dataset.position < lastColumn) {
                            c.classList.add('highlight');
                        }
                    });
                })
                updateStatus('선택 영역 이동됨');
            } catch (e) {
                writer.value = contentBackup
                writer.dispatchEvent(new Event('input', {bubbles: true, cancelable: true}));
                selectionBackup.forEach((v) => {
                    const chars = document.querySelectorAll('.char:not(.eof)');

                    chars.forEach(c => {
                        if (parseInt(c.dataset.position) === parseInt(v)) {
                            c.classList.add('highlight');
                        }
                    });
                })
                updateStatus('이동할 수 없는 위치입니다');
            }
        }
    }

    document.addEventListener("keydown", function (event) {
        const highlight = document.querySelector('.highlight');
        if (highlight !== null) {
            if (event.shiftKey && event.key === 'ArrowLeft') {
                event.preventDefault();
                moveSelected(-1, 0);
            } else if (event.shiftKey && event.key === 'ArrowDown') {
                event.preventDefault();
                moveSelected(0, 1);
            } else if (event.shiftKey && event.key === 'ArrowUp') {
                event.preventDefault();
                moveSelected(0, -1);
            } else if (event.shiftKey && event.key === 'ArrowRight') {
                event.preventDefault();
                moveSelected(1, 0);
            }
        }
    })

    document.addEventListener("undo", function (event) {
        event.preventDefault();

        history.pop()
    })

    function focusWriter() {
        const firstHighlight = document.querySelector('.highlight');

        if (firstHighlight === null) {
            writer.focus()
        } else {
            const position = parseInt(firstHighlight.dataset.position);
            writer.setSelectionRange(position, position);
            writer.focus();
        }
    }

    writer.addEventListener('input', function () {

        let value = writer.value;
        let position = 0;
        let panelResult = "";

        const lineSplit = value.split(/\n/g);
        let lineIndex;
        for (lineIndex = 0; lineIndex < lineSplit.length; lineIndex++) {
            const columnSplit = lineSplit[lineIndex].split('');
            let columnIndex;
            for (columnIndex = 0; columnIndex < columnSplit.length; columnIndex++) {
                panelResult += '<span class="char" data-line="' + lineIndex + '" data-column="' + columnIndex + '" data-position="' + position++ + '">' + columnSplit[columnIndex] + '</span>'
            }
            if (lineIndex + 1 < lineSplit.length) {
                panelResult += '<span class="char eof" data-line="' + lineIndex + '" data-column="' + columnIndex + '" data-position="' + position++ + '">&#8629;<br /></span>'
            }
        }

        panel.innerHTML = panelResult;
        updateSelectionUI();

        // 캔버스 크기 고정 시 범위 초과 체크
        const fixedCanvas = document.getElementById('fixedCanvasCheckbox').checked;
        if (fixedCanvas && !isRestoring) {
            const bezel = document.querySelector('.bezel');
            if (panel.scrollHeight > bezel.clientHeight || panel.scrollWidth > bezel.clientWidth) {
                // 초과 시 이전 값으로 복원
                isRestoring = true;
                writer.value = lastValidValue;
                writer.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                isRestoring = false;
                updateStatus('캔버스 범위를 초과했습니다');
                return;
            }
        }
        if (!isRestoring) {
            lastValidValue = writer.value;
        }
    });

    let isDragging = false;
    let selectionBox = null;
    let startX = 0;
    let startY = 0;

    panel.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.pageX;
        startY = e.pageY;

        selectionBox = document.createElement('div');
        selectionBox.classList.add('selection-box');
        document.body.appendChild(selectionBox);

        selectionBox.style.left = `${startX}px`;
        selectionBox.style.top = `${startY}px`;
        selectionBox.style.width = '0';
        selectionBox.style.height = '0';
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const width = e.pageX - startX;
        const height = e.pageY - startY;

        selectionBox.style.width = `${Math.abs(width)}px`;
        selectionBox.style.height = `${Math.abs(height)}px`;
        selectionBox.style.left = width > 0 ? `${startX}px` : `${e.pageX}px`;
        selectionBox.style.top = height > 0 ? `${startY}px` : `${e.pageY}px`;

        const selectionRect = selectionBox.getBoundingClientRect();
        const chars = document.querySelectorAll('.char:not(.eof)');

        chars.forEach(c => {
            const cRect = c.getBoundingClientRect();
            if (isOverlap(selectionRect, cRect)) {
                c.classList.add('highlight');
            } else {
                c.classList.remove('highlight');
            }
        });

    });

    document.addEventListener('mouseup', () => {
        if (!isDragging) return;
        isDragging = false;

        const selectionRect = selectionBox.getBoundingClientRect();
        const chars = document.querySelectorAll('.char:not(.eof)');
        let selectedCount = 0;

        chars.forEach(c => {
            const cRect = c.getBoundingClientRect();
            if (isOverlap(selectionRect, cRect)) {
                c.classList.add('highlight');
                selectedCount++;
            } else {
                c.classList.remove('highlight');
            }
        });
        getSelection();
        updateSelectionUI();

        if (selectedCount > 0) {
            updateStatus(`${selectedCount} characters selected`);
        }

        document.body.removeChild(selectionBox);
        selectionBox = null;
    });

    function isOverlap(rect1, rect2) {
        return !(rect1.right < rect2.left ||
            rect1.left > rect2.right ||
            rect1.bottom < rect2.top ||
            rect1.top > rect2.bottom);
    }

    // Theme toggle
    function toggleTheme() {
        const body = document.body;
        if (body.getAttribute('data-theme') === 'dark') {
            body.removeAttribute('data-theme');
            localStorage.setItem('theme', 'light');
        } else {
            body.setAttribute('data-theme', 'dark');
            localStorage.setItem('theme', 'dark');
        }
    }

    // Load saved theme
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
        document.body.setAttribute('data-theme', 'dark');
    }

    // Initialize
    updateStatus('준비됨 - 캔버스를 클릭하여 편집 시작');
</script>
</body>
</html>
